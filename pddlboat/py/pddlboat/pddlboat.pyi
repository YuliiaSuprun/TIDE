from typing import Any, ClassVar, Dict, List, Optional, Tuple

from typing import overload

class AStarPlanner(Planner):
    class Options:
        heuristic: Any
        transition_distance: Any
        verbose: bool
        def __init__(self) -> None: ...
    default_transition_distance: ClassVar[Any] = ...  # read-only
    null_heuristic: ClassVar[Any] = ...  # read-only
    total_cost_transition_distance: ClassVar[Any] = ...  # read-only
    options: Any
    def __init__(self, arg0, arg1) -> None: ...
    def block_state_actions(self, arg0, arg1) -> None: ...
    def generate_graph_ml(self, arg0: str) -> None: ...
    def get_start_neighbors(self, *args, **kwargs) -> Any: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    def initialize(self) -> None: ...
    def random_walk(self, *args, **kwargs) -> Any: ...
    @overload
    def solve(self, arg0) -> bool: ...
    @overload
    def solve(self, arg0, arg1: int) -> bool: ...

class Action:
    def __init__(self, arg0: str, arg1, arg2: Expression, arg3: Expression) -> None: ...
    def arity(self) -> int: ...
    def do_action(self, arg0: State, arg1: State, arg2) -> bool: ...
    def effected(self, arg0: State, arg1) -> bool: ...
    def holds(self, arg0: State, arg1) -> bool: ...
    def to_id(self, arg0) -> str: ...
    def to_step_id(self, arg0) -> str: ...
    @property
    def effect(self) -> Expression: ...
    @property
    def name(self) -> str: ...
    @property
    def parameters(self) -> Any: ...
    @property
    def precondition(self) -> Expression: ...

class And(VariadicExpression):
    def __init__(self, arg0: List[Expression]) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class AssignNumber(Expression):
    @overload
    def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0, arg1: float) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_lhs(self, *args, **kwargs) -> Any: ...
    def get_lhs_value(self, arg0, arg1) -> float: ...
    def get_rhs(self, *args, **kwargs) -> Any: ...
    def get_rhs_value(self, arg0, arg1) -> float: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class AssignObject(Expression):
    def __init__(self, arg0, arg1: Value) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class Assignment:
    var_to_obj: Any
    var_to_type: Dict[str,str]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Assignment) -> None: ...
    def arity(self) -> int: ...
    def assign(self, arg0: Problem, arg1: str, arg2: str) -> None: ...
    def assigned(self, *args, **kwargs) -> Any: ...
    def fold(self, arg0: Assignment) -> None: ...
    def get_variables(self) -> Set[str]: ...
    def is_assigned(self, arg0: str) -> bool: ...
    def type(self, arg0: str, arg1: str) -> None: ...
    def typed(self, arg0: str) -> str: ...
    def unassign(self, arg0: str) -> None: ...

class Axiom:
    def __init__(self, arg0, arg1: Expression, arg2: Expression) -> None: ...
    def arity(self) -> int: ...
    def holds(self, arg0: State, arg1) -> bool: ...
    def relevant(self, arg0: State, arg1) -> bool: ...
    @property
    def context(self) -> Expression: ...
    @property
    def implies(self) -> Expression: ...
    @property
    def parameters(self) -> Any: ...

class BinaryExpression(NumericExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_lhs(self) -> NumericExpression: ...
    def get_rhs(self) -> NumericExpression: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...

class Decrease(AssignNumber):
    @overload
    def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0, arg1: float) -> None: ...
    def get_rhs_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class DerivedPredicate(Expression):
    bindings: List[Value]
    def __init__(self, arg0, arg1: List[Value]) -> None: ...
    def arguments(self, *args, **kwargs) -> Any: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def name(self) -> str: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def to_id(self, arg0, arg1) -> str: ...
    def type(self, *args, **kwargs) -> Any: ...

class DerivedPredicateDefinition:
    expression: Expression
    def __init__(self, arg0: str, arg1, arg2: Expression) -> None: ...
    def arity(self) -> int: ...
    @overload
    def bind(self) -> DerivedPredicate: ...
    @overload
    def bind(self, arg0: List[str]) -> DerivedPredicate: ...
    @overload
    def bind(self, arg0: List[str], arg1: Problem, arg2: Domain) -> DerivedPredicate: ...
    def bind_values(self, arg0: List[Value]) -> DerivedPredicate: ...
    def is_valid_assignment(self, arg0: Problem, arg1: List[str]) -> bool: ...
    def set_formula(self, arg0: Expression) -> None: ...
    def to_id(self, arg0) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def parameters(self) -> Any: ...

class Divide(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class Domain:
    actions: Any
    axioms: Any
    constants: Any
    derived: Any
    functions: Any
    predicates: Any
    requirements: Any
    types: Dict[str,str]
    def __init__(self, arg0: str) -> None: ...
    def add_action(self, arg0) -> None: ...
    def add_axiom(self, arg0) -> None: ...
    @overload
    def add_constant(self, arg0) -> None: ...
    @overload
    def add_constant(self, arg0: str, arg1: str) -> None: ...
    def add_derived_predicate(self, arg0) -> None: ...
    def add_function(self, arg0) -> None: ...
    def add_predicate(self, arg0) -> None: ...
    def add_requirement(self, arg0) -> None: ...
    def add_requirements_from_expression(self, arg0: Expression) -> None: ...
    def add_type(self, arg0: str, arg1: str) -> None: ...
    def compare_types(self, arg0: str, arg1: str) -> bool: ...
    def find_common_type(self, arg0: str, arg1: str) -> str: ...
    def get_action(self, *args, **kwargs) -> Any: ...
    def get_constant(self, *args, **kwargs) -> Any: ...
    def get_derived_predicate(self, *args, **kwargs) -> Any: ...
    def get_function(self, *args, **kwargs) -> Any: ...
    def get_numeric_function(self, *args, **kwargs) -> Any: ...
    def get_object_function(self, *args, **kwargs) -> Any: ...
    def get_parent(self, arg0: str) -> str: ...
    def get_predicate(self, *args, **kwargs) -> Any: ...
    def get_types(self) -> List[str]: ...
    def has_requirements(self, arg0) -> bool: ...
    def is_derived_predicate(self, arg0: str) -> bool: ...
    def is_function(self, arg0: str) -> bool: ...
    def is_numeric_function(self, arg0: str) -> bool: ...
    def is_object_function(self, arg0: str) -> bool: ...
    def is_predicate(self, arg0: str) -> bool: ...
    def is_type(self, arg0: str) -> bool: ...
    def is_type_of(self, arg0: str, arg1: str) -> bool: ...
    def remove_function(self, arg0: str) -> None: ...
    def remove_predicate(self, arg0: str) -> None: ...
    def supports_requirements(self, arg0) -> bool: ...
    @property
    def name(self) -> str: ...

class Equals(Expression):
    def __init__(self, arg0: Value, arg1: Value) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def get_terms(self) -> Tuple[Value,Value]: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class Exists(QuantifierExpression):
    def __init__(self, arg0, arg1: Expression) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class Expression:
    class Effect:
        add: Set[str]
        assigned: Set[str]
        remove: Set[str]
        def __init__(self, *args, **kwargs) -> None: ...
        def absorb(self, arg0: Expression.Effect) -> None: ...
        def flip(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class FastDownwardPlanner(Planner):
    class Options:
        no_simplify_sas: bool
        search: Any
        def __init__(self) -> None: ...
    def __init__(self, arg0, arg1) -> None: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    @overload
    def solve(self, arg0) -> bool: ...
    @overload
    def solve(self, arg0, arg1: int) -> bool: ...
    def update(self, arg0: bool, arg1: bool) -> None: ...

class FastForwardPlanner(Planner):
    class Options:
        def __init__(self) -> None: ...
    def __init__(self, arg0, arg1) -> None: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    @overload
    def solve(self, arg0) -> bool: ...
    @overload
    def solve(self, arg0, arg1: int) -> bool: ...
    def update(self, arg0: bool, arg1: bool) -> None: ...

class Forall(QuantifierExpression):
    def __init__(self, arg0, arg1: Expression) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class FunctionDefinition:
    def __init__(self, arg0: str, arg1, arg2: str) -> None: ...
    def arity(self) -> int: ...
    def is_valid_assignment(self, arg0: Problem, arg1: List[str]) -> bool: ...
    def to_id(self, arg0) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def parameters(self) -> Any: ...
    @property
    def type(self) -> str: ...

class GreaterOrEqual(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class GreaterThan(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class GroundedAction:
    __hash__: ClassVar[None] = ...
    def __init__(self, arg0, arg1) -> None: ...
    def __eq__(self, arg0: GroundedAction) -> bool: ...
    @property
    def action(self) -> Any: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def string(self) -> str: ...

class GroundedAxiom:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def axiom(self) -> Any: ...

class GroundedDerivedPredicate:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def derived(self) -> Any: ...
    @property
    def string(self) -> str: ...

class GroundedExpression:
    def __init__(self, arg0: Expression, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def expression(self) -> Expression: ...

class GroundedFunction:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def fluent(self) -> Any: ...
    @property
    def string(self) -> str: ...

class GroundedNumericFunction:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def fluent(self) -> Any: ...
    @property
    def string(self) -> str: ...

class GroundedObjectFunction:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def fluent(self) -> Any: ...
    @property
    def string(self) -> str: ...

class GroundedPredicate:
    def __init__(self, arg0, arg1) -> None: ...
    @property
    def assignment(self) -> Any: ...
    @property
    def predicate(self) -> Any: ...
    @property
    def string(self) -> str: ...

class Imply(Expression):
    def __init__(self, arg0: Expression, arg1: Expression) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_left(self) -> Expression: ...
    def get_right(self) -> Expression: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class Increase(AssignNumber):
    @overload
    def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0, arg1: float) -> None: ...
    def get_rhs_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class LessOrEqual(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class LessThan(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class Minus(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class Multiply(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class Not(Expression):
    def __init__(self, arg0: Expression) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def get_term(self) -> Expression: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class NumericExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...

class NumericFunction(NumericExpression):
    bindings: List[Value]
    def __init__(self, arg0, arg1: List[Value]) -> None: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_name(self) -> str: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def to_id(self, arg0, arg1) -> str: ...
    def type(self, *args, **kwargs) -> Any: ...

class NumericFunctionDefinition(FunctionDefinition):
    def __init__(self, arg0: str, arg1) -> None: ...
    @overload
    def bind(self) -> NumericFunction: ...
    @overload
    def bind(self, arg0: List[str], arg1: Problem, arg2: Domain) -> NumericFunction: ...
    def bind_values(self, arg0: List[Value]) -> NumericFunction: ...

class Object:
    name: str
    type: str
    def __init__(self, arg0: str, arg1: str) -> None: ...

class ObjectFunction(Expression):
    bindings: List[Value]
    def __init__(self, arg0, arg1: List[Value]) -> None: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0: Expression.Effect, arg1, arg2) -> None: ...
    def get_name(self) -> str: ...
    def get_object(self, arg0, arg1) -> str: ...
    def get_return_type(self) -> str: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def to_id(self, arg0, arg1) -> str: ...
    def type(self, *args, **kwargs) -> Any: ...

class ObjectFunctionDefinition(FunctionDefinition):
    def __init__(self, arg0: str, arg1, arg2: str) -> None: ...
    @overload
    def bind(self) -> ObjectFunction: ...
    @overload
    def bind(self, arg0: List[str]) -> ObjectFunction: ...
    @overload
    def bind(self, arg0: List[str], arg1: Problem) -> ObjectFunction: ...
    def bind_values(self, arg0: List[Value]) -> ObjectFunction: ...

class Or(VariadicExpression):
    def __init__(self, arg0: List[Expression]) -> None: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def type(self, *args, **kwargs) -> Any: ...

class Plan:
    class Step:
        action: Any
        assignment: Any
        prior: Any
        state: Any
        def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...
    @overload
    def __init__(self, arg0: Plan) -> None: ...
    def add_step(self, *args, **kwargs) -> Any: ...
    def add_step_action(self, *args, **kwargs) -> Any: ...
    def get_makespan(self) -> int: ...
    def get_makespan_steps(self, *args, **kwargs) -> Any: ...
    def get_num_steps(self) -> int: ...
    def get_problem(self, *args, **kwargs) -> Any: ...
    def get_step(self, *args, **kwargs) -> Any: ...
    def get_step_const(self, *args, **kwargs) -> Any: ...
    def get_step_states(self, *args, **kwargs) -> Any: ...
    def get_steps(self, *args, **kwargs) -> Any: ...
    def get_steps_at_makespan(self, *args, **kwargs) -> Any: ...
    def get_time_taken(self, arg0: str) -> float: ...
    def insert_step(self, *args, **kwargs) -> Any: ...
    def insert_step_action(self, *args, **kwargs) -> Any: ...
    def set_time_taken(self, arg0: str, arg1: float) -> None: ...
    def validate(self) -> bool: ...

class PlanDependencyGraph:
    class ActionNode:
        eff_state: State
        leafdist: int
        makespan: int
        pre_state: State
        def __init__(self, *args, **kwargs) -> None: ...
        def get_interaction(self, arg0: PlanDependencyGraph.ActionNode) -> Set[str]: ...
        def is_effected(self, arg0: PlanDependencyGraph.ActionNode) -> bool: ...
        def is_prior(self, arg0: PlanDependencyGraph.ActionNode) -> bool: ...
        @property
        def action(self) -> Action: ...
        @property
        def assignment(self) -> Assignment: ...
        @property
        def eff_pred(self) -> Set[str]: ...
        @property
        def plan_index(self) -> int: ...
        @property
        def pre_pred(self) -> Set[str]: ...

    class DotFileOptions:
        action: bool
        color_leafs: bool
        color_terminals: bool
        draw_end: bool
        draw_start: bool
        edge_tool_tips: bool
        index: bool
        ranking: Any
        state_tool_tips: bool
        def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Plan) -> None: ...
    @overload
    def __init__(self, arg0: Plan) -> None: ...
    @overload
    def __init__(self, arg0: PlanDependencyGraph) -> None: ...
    def compute_node_states(self) -> None: ...
    def get_children(self, *args, **kwargs) -> Any: ...
    def get_descendants(self, *args, **kwargs) -> Any: ...
    def get_leafs(self, *args, **kwargs) -> Any: ...
    def get_max_leaf_distance(self) -> int: ...
    def get_max_makespan(self) -> int: ...
    def get_nodes(self, *args, **kwargs) -> Any: ...
    def get_nodes_by_leaf_distance(self, *args, **kwargs) -> Any: ...
    def get_nodes_by_makespan(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_greater_leaf_distance(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_greater_makespan(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_leaf_distance(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_less_leaf_distance(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_less_makespan(self, *args, **kwargs) -> Any: ...
    def get_nodes_with_makespan(self, *args, **kwargs) -> Any: ...
    def get_parents(self, *args, **kwargs) -> Any: ...
    def get_plan_step(self, *args, **kwargs) -> Any: ...
    def get_predecessors(self, *args, **kwargs) -> Any: ...
    def initialize(self) -> None: ...
    def is_ancestor(self, arg0, arg1) -> bool: ...
    def is_child(self, arg0, arg1) -> bool: ...
    def is_descendant(self, arg0, arg1) -> bool: ...
    def is_parent(self, arg0, arg1) -> bool: ...
    def remove_node(self, arg0) -> bool: ...
    def to_dot_file(self, *args, **kwargs) -> Any: ...

class PlanSet:
    @overload
    def __init__(self, arg0) -> None: ...
    @overload
    def __init__(self, arg0: PlanSet) -> None: ...
    def add_plan(self, arg0) -> None: ...
    def begin(self, *args, **kwargs) -> Any: ...
    def cbegin(self, *args, **kwargs) -> Any: ...
    def cend(self, *args, **kwargs) -> Any: ...
    def clear(self) -> None: ...
    def count(self) -> int: ...
    def end(self, *args, **kwargs) -> Any: ...
    def get_plan(self, *args, **kwargs) -> Any: ...
    def get_plan_const(self, *args, **kwargs) -> Any: ...
    def get_problem(self, *args, **kwargs) -> Any: ...
    def new_plan(self, *args, **kwargs) -> Any: ...
    def __getitem__(self, index) -> Any: ...

class PlanWatcher:
    def __init__(self, arg0, arg1: str, arg2, arg3: str, arg4: bool, arg5: int, arg6: int) -> None: ...
    def get_next_plan_idx(self) -> Optional[int]: ...
    def get_plan_idx(self) -> int: ...
    def get_plans(self, *args, **kwargs) -> Any: ...
    def planner_running(self) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class Planner:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_constraint(self, arg0, arg1, arg2: bool) -> None: ...
    def block_expression_action(self, arg0, arg1, arg2, arg3) -> None: ...
    def block_expression_actions(self, arg0, arg1, arg2) -> None: ...
    def block_plan_step(self, arg0, arg1: int) -> None: ...
    def block_state_action(self, arg0, arg1, arg2) -> None: ...
    def block_state_actions(self, arg0, arg1) -> None: ...
    def block_state_actions_simultaneous(self, arg0, arg1) -> None: ...
    def check_requirements(self) -> None: ...
    def get_problem(self, *args, **kwargs) -> Any: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    def reset(self) -> None: ...
    @overload
    def solve(self, arg0) -> bool: ...
    @overload
    def solve(self, arg0, arg1: int) -> bool: ...

class Plus(BinaryExpression):
    def __init__(self, arg0: NumericExpression, arg1: NumericExpression) -> None: ...
    def get_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class Predicate(Expression):
    bindings: List[Value]
    def __init__(self, arg0, arg1: List[Value]) -> None: ...
    def arguments(self, *args, **kwargs) -> Any: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_definition(self, *args, **kwargs) -> Any: ...
    def get_effects(self, arg0: Expression.Effect, arg1, arg2) -> None: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def name(self) -> str: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def to_id(self, arg0, arg1) -> str: ...
    def type(self, *args, **kwargs) -> Any: ...

class PredicateDefinition:
    def __init__(self, arg0: str, arg1) -> None: ...
    def arity(self) -> int: ...
    @overload
    def bind(self, arg0: List[str]) -> Predicate: ...
    @overload
    def bind(self, arg0: List[str], arg1: Problem) -> Predicate: ...
    def bind_values(self, arg0: List[Value]) -> Predicate: ...
    def is_valid_assignment(self, arg0: Problem, arg1: List[str]) -> bool: ...
    def to_id(self, arg0) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def variables(self) -> Any: ...

class Problem:
    goal: Expression
    metric: Expression
    minimize: bool
    objects: Any
    start: State
    @overload
    def __init__(self, arg0: str, arg1) -> None: ...
    @overload
    def __init__(self, arg0: Problem) -> None: ...
    @overload
    def __init__(self, arg0: Problem) -> None: ...
    @overload
    def add_object(self, arg0) -> None: ...
    @overload
    def add_object(self, arg0: str, arg1: str) -> None: ...
    def axioms_hold(self, arg0: State) -> bool: ...
    def get_groundings(self, *args, **kwargs) -> Any: ...
    def get_object(self, *args, **kwargs) -> Any: ...
    def make_state(self) -> State: ...
    def objects_of_type(self, arg0: str) -> List[str]: ...
    @property
    def domain(self) -> Any: ...
    @property
    def name(self) -> str: ...

class QuantifierExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_domain(self, *args, **kwargs) -> Any: ...
    def get_formula(self) -> Expression: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class ScaleDown(AssignNumber):
    @overload
    def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0, arg1: float) -> None: ...
    def get_rhs_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class ScaleUp(AssignNumber):
    @overload
    def __init__(self, arg0, arg1) -> None: ...
    @overload
    def __init__(self, arg0, arg1: float) -> None: ...
    def get_rhs_value(self, arg0, arg1) -> float: ...
    def type(self, *args, **kwargs) -> Any: ...

class State:
    assignments: Dict[Tuple[str,List[str]],bool]
    numeric: Dict[Tuple[str,List[str]],float]
    values: Dict[Tuple[str,List[str]],str]
    def __init__(self, arg0) -> None: ...
    @overload
    def assign0(self, arg0: str, arg1: bool) -> None: ...
    @overload
    def assign0(self, arg0: str, arg1: float) -> None: ...
    @overload
    def assign0(self, arg0: str, arg1: str) -> None: ...
    @overload
    def assign1(self, arg0: str, arg1: str, arg2: bool) -> None: ...
    @overload
    def assign1(self, arg0: str, arg1: str, arg2: float) -> None: ...
    @overload
    def assign1(self, arg0: str, arg1: str, arg2: str) -> None: ...
    @overload
    def assign_n(self, arg0: str, arg1: List[str], arg2: bool) -> None: ...
    @overload
    def assign_n(self, arg0: str, arg1: List[str], arg2: float) -> None: ...
    @overload
    def assign_n(self, arg0: str, arg1: List[str], arg2: str) -> None: ...
    def clean(self) -> None: ...
    def clean_clone(self) -> State: ...
    def clear(self) -> None: ...
    def clone(self) -> State: ...
    def complement(self) -> None: ...
    @overload
    def fold(self, arg0: State) -> None: ...
    @overload
    def fold(self, arg0: State) -> None: ...
    def get_object(self, arg0: str, arg1: List[str]) -> str: ...
    def get_objects(self) -> List[str]: ...
    def get_problem(self, *args, **kwargs) -> Any: ...
    def get_value(self, arg0: str, arg1: List[str]) -> float: ...
    def hash(self) -> int: ...
    @overload
    def is_equal(self, arg0: State) -> bool: ...
    @overload
    def is_equal(self, arg0: State) -> bool: ...
    def is_true(self, arg0: str, arg1: List[str]) -> bool: ...
    def set_problem(self, arg0) -> None: ...
    def strip(self, arg0: State) -> None: ...
    def get_true_predicates(self) -> list[tuple[str, list[str]]]: ...

class SymKPlanner(FastDownwardPlanner):
    def __init__(self, arg0, arg1, arg2: int, arg3: float, arg4: bool) -> None: ...
    def anytime_solve(self, *args, **kwargs) -> Any: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    def multi_solve(self, arg0) -> bool: ...

class Value:
    function: Any
    is_var: bool
    name: str
    type: str
    @overload
    def __init__(self, arg0: bool, arg1: str, arg2: str) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_object(self, arg0, arg1) -> str: ...
    def get_used_functions(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...

class Variable:
    __hash__: ClassVar[None] = ...
    name: str
    type: str
    @overload
    def __init__(self, arg0: Tuple[str,str]) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: str) -> None: ...
    def __eq__(self, arg0: Variable) -> bool: ...
    def __lt__(self, arg0: Variable) -> bool: ...
    def __ne__(self, arg0: Variable) -> bool: ...

class VariableSet:
    __hash__: ClassVar[None] = ...
    variables: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...
    def add_variable(self, arg0) -> None: ...
    def contains(self, arg0: VariableSet) -> bool: ...
    def get_names(self) -> Set[str]: ...
    def get_variable(self, *args, **kwargs) -> Any: ...
    def merge(self, arg0: VariableSet) -> None: ...
    @overload
    def remove(self, arg0: VariableSet) -> None: ...
    @overload
    def remove(self, arg0) -> None: ...
    def remove_variable(self, arg0) -> bool: ...
    def __eq__(self, arg0: VariableSet) -> bool: ...
    def __ne__(self, arg0: VariableSet) -> bool: ...

class VariadicExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    def add_term(self, arg0: Expression) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def get_terms(self) -> List[Expression]: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class When(Expression):
    def __init__(self, arg0: Expression, arg1: Expression) -> None: ...
    def assign(self, arg0, arg1, arg2) -> None: ...
    def contains_predicate(self, arg0: str) -> bool: ...
    def contains_variable(self, arg0: str) -> bool: ...
    def evaluate(self, arg0, arg1) -> bool: ...
    def get_assigned_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_effects(self, arg0, arg1, arg2) -> None: ...
    def get_left(self) -> Expression: ...
    def get_right(self) -> Expression: ...
    def get_types(self, *args, **kwargs) -> Any: ...
    def get_used_predicates(self, arg0: Set[str], arg1, arg2) -> None: ...
    def get_variables(self, arg0) -> None: ...
    def rename_variable(self, arg0: str, arg1: str) -> None: ...
    def type(self, *args, **kwargs) -> Any: ...

class Z3Planner(Planner):
    class Options:
        diagnostics: bool
        dump_clauses: bool
        horizon_max: int
        horizon_min: int
        incremental: bool
        optimize: bool
        parallel: bool
        simultaneous: bool
        def __init__(self) -> None: ...
    def __init__(self, arg0, arg1) -> None: ...
    def add_constraint(self, arg0, arg1, arg2: bool) -> None: ...
    def block_expression_actions(self, arg0, arg1, arg2) -> None: ...
    def block_state_actions(self, arg0, arg1) -> None: ...
    def block_state_actions_simultaneous(self, arg0, arg1) -> None: ...
    def get_supported_requirements(self, *args, **kwargs) -> Any: ...
    def print_model(self, *args, **kwargs) -> Any: ...
    def print_smt2(self, *args, **kwargs) -> Any: ...
    def reset(self) -> None: ...
    @overload
    def solve(self, arg0) -> bool: ...
    @overload
    def solve(self, arg0, arg1: int) -> bool: ...

def get_value(arg0: str, arg1: Variable, arg2: Problem, arg3: Domain) -> Value: ...
def get_value_objects(arg0: List[Value], arg1: State, arg2: Assignment) -> List[str]: ...
@overload
def get_values(arg0: List[str], arg1: List[Variable], arg2: Problem, arg3: Domain) -> List[Value]: ...
@overload
def get_values(arg0: List[str], arg1: List[Variable], arg2: Problem, arg3: Domain) -> List[Value]: ...
def get_variables(arg0) -> List[Variable]: ...
def is_in(arg0, arg1) -> bool: ...
def make_action(arg0: str, arg1: List[Variable], arg2: Expression, arg3: Expression) -> Action: ...
def make_and(arg0: List[Expression]) -> And: ...
@overload
def make_assign(arg0: ObjectFunction, arg1: Value) -> AssignObject: ...
@overload
def make_assign(arg0: NumericFunction, arg1: NumericExpression) -> AssignNumber: ...
@overload
def make_assign(arg0: NumericFunction, arg1: float) -> AssignNumber: ...
def make_axiom(arg0: List[Variable], arg1: Expression, arg2: Expression) -> Axiom: ...
@overload
def make_decrease(arg0: NumericFunction, arg1: NumericExpression) -> Decrease: ...
@overload
def make_decrease(arg0: NumericFunction, arg1: float) -> Decrease: ...
def make_derived_pred(arg0: str, arg1: List[Variable], arg2: Expression) -> DerivedPredicateDefinition: ...
def make_divide(arg0: NumericExpression, arg1: NumericExpression) -> Divide: ...
def make_equals(arg0: Value, arg1: Value) -> Equals: ...
def make_exists(arg0: VariableSet, arg1: Expression) -> Exists: ...
def make_forall(arg0: VariableSet, arg1: Expression) -> Forall: ...
def make_function(arg0: str, arg1: List[Variable]) -> NumericFunctionDefinition: ...
def make_greater_or_equal(arg0: NumericExpression, arg1: NumericExpression) -> GreaterOrEqual: ...
def make_greater_than(arg0: NumericExpression, arg1: NumericExpression) -> GreaterThan: ...
def make_imply(arg0: Expression, arg1: Expression) -> Imply: ...
@overload
def make_increase(arg0: NumericFunction, arg1: NumericExpression) -> Increase: ...
@overload
def make_increase(arg0: NumericFunction, arg1: float) -> Increase: ...
def make_less_or_equal(arg0: NumericExpression, arg1: NumericExpression) -> LessOrEqual: ...
def make_less_than(arg0: NumericExpression, arg1: NumericExpression) -> LessThan: ...
def make_minus(arg0: NumericExpression, arg1: NumericExpression) -> Minus: ...
def make_multiply(arg0: NumericExpression, arg1: NumericExpression) -> Multiply: ...
def make_no_op_action(arg0: str) -> Action: ...
def make_not(arg0: Expression) -> Not: ...
def make_obj(arg0: str, arg1: str) -> Object: ...
def make_object_function(arg0: str, arg1: str, arg2: List[Variable]) -> ObjectFunctionDefinition: ...
def make_or(arg0: List[Expression]) -> Or: ...
def make_plus(arg0: NumericExpression, arg1: NumericExpression) -> Plus: ...
def make_pred(arg0: str, arg1: List[Variable]) -> PredicateDefinition: ...
@overload
def make_scale_down(arg0: NumericFunction, arg1: NumericExpression) -> ScaleDown: ...
@overload
def make_scale_down(arg0: NumericFunction, arg1: float) -> ScaleDown: ...
@overload
def make_scale_up(arg0: NumericFunction, arg1: NumericExpression) -> ScaleUp: ...
@overload
def make_scale_up(arg0: NumericFunction, arg1: float) -> ScaleUp: ...
def make_when(arg0: Expression, arg1: Expression) -> When: ...
def parse_domain(arg0: str) -> Domain: ...
def parse_problem(arg0: Domain, arg1: str) -> Problem: ...
def to_action(arg0, arg1: Domain) -> Action: ...
def to_axiom(arg0, arg1: Domain) -> Axiom: ...
def to_derived(arg0, arg1: Domain) -> DerivedPredicateDefinition: ...
def to_domain(arg0) -> Domain: ...
def to_expression(arg0, arg1: List[Variable], arg2: Domain, arg3: Problem) -> Expression: ...
def to_problem(arg0, arg1: Domain) -> Problem: ...
